---
title: Pre-Game Interview
date: 2025-4-15
tags:
  - UE5
  - C++
  - Game Development
categories: [C++]
description: 基础知识
---

# C++ 基础知识

## 1.1 多态、虚函数

- 什么是多态？C++的多态是如何实现的？
    答：所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态，编译时多态也称为为静态联编，通过重载和模板来实现，运行时多态称为动态联编，通过继承和虚函数来实现。
   - 重载和模板
     - 函数重载：同一个函数名可以有多个不同的参数列表，编译器根据参数类型和数量来决定调用哪个函数。
     - 实现编译时多态的原理：在编译阶段，编译器根据函数调用语句中提供的参数类型和个数等信息，在符号表中查找与之匹配的函数定义，确定具体要调用的函数版本。由于这种函数调用的绑定是在编译期间完成的，所以称为编译时多态（静态联编）。
     - 模板：函数模板和类模板，允许在编译时生成不同类型的函数或类。
     - 实现编译时多态的原理：在编译阶段，当编译器遇到模板函数的调用时，会根据实际传入的参数类型，对模板进行实例化，生成具体的函数代码。不同的参数类型会导致生成不同的函数实例，从而实现了在编译时根据不同的数据类型调用不同的函数版本，达到编译时多态（静态联编）的效果。
   - 继承和虚函数
     - 继承：允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的复用和扩展。
     - 虚函数：在父类中声明为虚函数的方法，允许在子类中重写，从而实现运行时多态。
     - 实现运行时多态的原理：当一个类包含虚函数时，编译器会为该类生成一个虚函数表（vtable），虚函数表中存储了该类所有虚函数的地址。在类对象的内存空间中，会有一个指向虚函数表的指针（虚表指针）。当通过基类指针或引用调用虚函数时，程序会根据这个虚表指针找到对应的虚函数表，然后根据虚函数表中存储的函数地址来调用实际的函数。由于派生类重写虚函数时会更新虚函数表中相应的函数地址，所以通过基类指针或引用调用虚函数时，能够根据对象的实际类型（是基类对象还是派生类对象）来调用正确的函数版本，实现了运行时多态（动态联编）。
    - lua通过metatable实现多态，metatable是lua中一个特殊的表，用于实现对象的行为和属性的重载。通过设置metatable，可以定义对象的行为，比如加法、减法等操作符的重载，以及方法的调用等。lua中的多态主要体现在函数和方法的调用上，通过不同的参数类型和数量，可以实现不同的行为。lua中的多态是通过动态类型系统来实现的，不同于C++中的静态类型系统，lua在运行时根据实际传入的参数类型来决定调用哪个函数或方法，从而实现多态性。

**类对象的头部存放着一个虚指针，该虚指针指向了各自类所维护的虚函数表，再通过查找虚函数表中的地址来找到对应的虚函数**
**在使用基类指针调用虚函数的时候，它能够根据所指的类对象的不同来正确调用虚函数。而这些能够正常工作，得益于虚指针和虚函数表的引入，使得在程序运行期间能够动态调用函数。**

> 基类 Animal 的虚函数表： https://zhuanlan.zhihu.com/p/98776075
当编译器处理 Animal 类时，由于它包含虚函数 speak 和 move，会为 Animal 类生成一个虚函数表。
虚函数表中存储了这两个虚函数的地址，即 Animal::speak 和 Animal::move 的函数地址。
派生类 Dog 的虚函数表：
Dog 类继承自 Animal 类，并且重写了 speak 和 move 函数。
编译器会为 Dog 类生成自己的虚函数表，该虚函数表首先继承了 Animal 类虚函数表的结构。
然后，对于重写的函数，虚函数表中相应的函数地址会被更新为 Dog::speak 和 Dog::move 的函数地址。
派生类 Cat 的虚函数表：
同理，Cat 类也继承自 Animal 类，并重写了 speak 和 move 函数。
编译器为 Cat 类生成虚函数表，继承 Animal 类虚函数表结构，同时将重写函数的地址更新为 Cat::speak 和 Cat::move 的函数地址。

- 虚函数的实现机制是什么？
  - 答：虚函数是通过虚函数表来实现的，虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数。

- 虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？
答：运行时确定，通过查找虚函数表中的函数地址确定。更正：此处说法不严谨，应该是只有通过指针或者引用的方式调用虚函数是运行时确定，通过值调用的虚函数是编译期就可以确定的，参考这篇文章，虚函数一定是运行期才绑定么？https://www.zhihu.com/question/491602524/answer/2165605549

- 虚函数是存在类中还是类对象中（即是否共享虚表）？
答：存在类中，不同的类对象共享一张虚函数表(为了节省内存空间)。

**动态绑定是根据对象的实际类型在运行时确定调用虚函数的具体版本**

- 在(基类的)构造函数和析构函数中调用虚函数会怎么样？
【参考资料】：《Effective C++》条款9、https://www.cnblogs.com/sylar5/p/11523992.html
答：从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，此时子类还没有构造，所以此时的对象还是父类的，不会触发多态。更容易记的是基类构造期间，virtual函数不是virtual函数。

- C语言可以实现虚函数机制吗，如何实现？
【参考资料】：C语言实现虚函数机制 https://blog.csdn.net/mieleizhi0522/article/details/100674868
答：需要做的工作：手动构造父子关系、创建虚函数表、设置虚表指针并指向虚函数表、填充虚函数表；当虚函数重写的时候还需要手动修改函数指针等等。

## 1.2 内存模型、继承问题

- c++中类对象的内存模型(布局)是怎么样的？
参考资料】：C++内存模型 - MrYun - 博客园 (cnblogs.com)、C++内存布局（上）_qinm的专栏-CSDN博客

答：一般遵循以下几点原则：

（1）如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部；

（2）除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局；

（3）如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局(虚表指针+字段）；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到第一个虚函数表的后面；

（4）如果有钻石继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(最上方的父类，包含虚表)，并且各个父类不再拷贝公共基类中的数据成员。

- 钻石(菱形)继承存在什么问题，如何解决？
【参考资料】：C++之钻石问题和解决方案（菱形继承问题）_Benson的专栏-CSDN博客https://www.cnblogs.com/yunlambert/p/9876491.html、C++：钻石继承与虚继承 - Tom文星 - 博客园 (cnblogs.com)https://blog.csdn.net/u012658346/article/details/50775742

答：会存在二义性的问题，因为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题(父类继承公共基类时用virtual修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。