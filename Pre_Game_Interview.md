---
title: Pre-Game Interview
date: 2025-4-15
tags:
  - UE5
  - C++
  - Game Development
categories: [C++]
description: 基础知识
---

# C++ 基础知识

## 1.1 多态、虚函数

- 什么是多态？C++的多态是如何实现的？
    答：所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态，编译时多态也称为为静态联编，通过重载和模板来实现，运行时多态称为动态联编，通过继承和虚函数来实现。
   - 重载和模板
     - 函数重载：同一个函数名可以有多个不同的参数列表，编译器根据参数类型和数量来决定调用哪个函数。
     - 实现编译时多态的原理：在编译阶段，编译器根据函数调用语句中提供的参数类型和个数等信息，在符号表中查找与之匹配的函数定义，确定具体要调用的函数版本。由于这种函数调用的绑定是在编译期间完成的，所以称为编译时多态（静态联编）。
     - 模板：函数模板和类模板，允许在编译时生成不同类型的函数或类。
     - 实现编译时多态的原理：在编译阶段，当编译器遇到模板函数的调用时，会根据实际传入的参数类型，对模板进行实例化，生成具体的函数代码。不同的参数类型会导致生成不同的函数实例，从而实现了在编译时根据不同的数据类型调用不同的函数版本，达到编译时多态（静态联编）的效果。
   - 继承和虚函数
     - 继承：允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的复用和扩展。
     - 虚函数：在父类中声明为虚函数的方法，允许在子类中重写，从而实现运行时多态。
     - 实现运行时多态的原理：当一个类包含虚函数时，编译器会为该类生成一个虚函数表（vtable），虚函数表中存储了该类所有虚函数的地址。在类对象的内存空间中，会有一个指向虚函数表的指针（虚表指针）。当通过基类指针或引用调用虚函数时，程序会根据这个虚表指针找到对应的虚函数表，然后根据虚函数表中存储的函数地址来调用实际的函数。由于派生类重写虚函数时会更新虚函数表中相应的函数地址，所以通过基类指针或引用调用虚函数时，能够根据对象的实际类型（是基类对象还是派生类对象）来调用正确的函数版本，实现了运行时多态（动态联编）。
    - lua通过metatable实现多态，metatable是lua中一个特殊的表，用于实现对象的行为和属性的重载。通过设置metatable，可以定义对象的行为，比如加法、减法等操作符的重载，以及方法的调用等。lua中的多态主要体现在函数和方法的调用上，通过不同的参数类型和数量，可以实现不同的行为。lua中的多态是通过动态类型系统来实现的，不同于C++中的静态类型系统，lua在运行时根据实际传入的参数类型来决定调用哪个函数或方法，从而实现多态性。

**类对象的头部存放着一个虚指针，该虚指针指向了各自类所维护的虚函数表，再通过查找虚函数表中的地址来找到对应的虚函数**
**在使用基类指针调用虚函数的时候，它能够根据所指的类对象的不同来正确调用虚函数。而这些能够正常工作，得益于虚指针和虚函数表的引入，使得在程序运行期间能够动态调用函数。**

> 基类 Animal 的虚函数表： https://zhuanlan.zhihu.com/p/98776075
当编译器处理 Animal 类时，由于它包含虚函数 speak 和 move，会为 Animal 类生成一个虚函数表。
虚函数表中存储了这两个虚函数的地址，即 Animal::speak 和 Animal::move 的函数地址。
派生类 Dog 的虚函数表：
Dog 类继承自 Animal 类，并且重写了 speak 和 move 函数。
编译器会为 Dog 类生成自己的虚函数表，该虚函数表首先继承了 Animal 类虚函数表的结构。
然后，对于重写的函数，虚函数表中相应的函数地址会被更新为 Dog::speak 和 Dog::move 的函数地址。
派生类 Cat 的虚函数表：
同理，Cat 类也继承自 Animal 类，并重写了 speak 和 move 函数。
编译器为 Cat 类生成虚函数表，继承 Animal 类虚函数表结构，同时将重写函数的地址更新为 Cat::speak 和 Cat::move 的函数地址。

- 虚函数的实现机制是什么？
  - 答：虚函数是通过虚函数表来实现的，虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数。

- 虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？
答：运行时确定，通过查找虚函数表中的函数地址确定。更正：此处说法不严谨，应该是只有通过指针或者引用的方式调用虚函数是运行时确定，通过值调用的虚函数是编译期就可以确定的，参考这篇文章，虚函数一定是运行期才绑定么？https://www.zhihu.com/question/491602524/answer/2165605549

- 虚函数是存在类中还是类对象中（即是否共享虚表）？
答：存在类中，不同的类对象共享一张虚函数表(为了节省内存空间)。

**动态绑定是根据对象的实际类型在运行时确定调用虚函数的具体版本**

- 在(基类的)构造函数和析构函数中调用虚函数会怎么样？
【参考资料】：《Effective C++》条款9、https://www.cnblogs.com/sylar5/p/11523992.html
答：从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，此时子类还没有构造，所以此时的对象还是父类的，不会触发多态。更容易记的是基类构造期间，virtual函数不是virtual函数。

- C语言可以实现虚函数机制吗，如何实现？
【参考资料】：C语言实现虚函数机制 https://blog.csdn.net/mieleizhi0522/article/details/100674868
答：需要做的工作：手动构造父子关系、创建虚函数表、设置虚表指针并指向虚函数表、填充虚函数表；当虚函数重写的时候还需要手动修改函数指针等等。

## 1.2 内存模型、继承问题

- c++中类对象的内存模型(布局)是怎么样的？
参考资料：C++内存模型 - MrYun - 博客园 (cnblogs.com)、C++内存布局（上）_qinm的专栏-CSDN博客

答：一般遵循以下几点原则：

（1）如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部；

（2）除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局；

（3）如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局(虚表指针+字段）；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到第一个虚函数表的后面；

（4）如果有钻石继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(最上方的父类，包含虚表)，并且各个父类不再拷贝公共基类中的数据成员。

- 钻石(菱形)继承存在什么问题，如何解决？
【参考资料】：C++之钻石问题和解决方案（菱形继承问题）_Benson的专栏-CSDN博客https://www.cnblogs.com/yunlambert/p/9876491.html、C++：钻石继承与虚继承 - Tom文星 - 博客园 (cnblogs.com)https://blog.csdn.net/u012658346/article/details/50775742

答：会存在二义性的问题，因为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题(父类继承公共基类时用virtual修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。

## 1.3 内存管理（内存分配、内存对齐）

- C++是如何做内存管理的（有哪些内存区域）?
【参考资料】：C++内存管理 - 还没放弃的老张 - 博客园 (cnblogs.com)https://www.cnblogs.com/learning-zjx/p/10645659.html

（1）堆，使用malloc、free动态分配和释放空间，能分配较大的内存；

（2）栈，为函数的局部变量分配内存，能分配较小的内存；

（3）全局/静态存储区，用于存储全局变量和静态变量；

（4）常量存储区，专门用来存放常量；

（5）自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。

补充：堆是C和操作系统的术语，自由存储区是C++的术语，指的是通过new和delete动态分配和释放对象的抽象概念；基本上C++也会用堆区实现自由存储，但程序员可以通过重载操作符，改用其他内存实现自由存储，比如全局变量做的对象池。

- 堆和栈的内存有什么区别？
（1）堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放；

（2）堆能分配的内存较大（4G(32位机器)），栈能分配的内存较小（1M）；

（3）在堆中分配和释放内存会产生内存碎片，栈不会产生内存碎片；

（4）堆的分配效率低，栈的分配效率高；

（5）堆地址从低向上，栈由高向下。

C++和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？
C使用malloc/free，C++使用new/delete，前者是C语言中的库函数，后者是C++语言的运算符，对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数，只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间，不能混用，具体区别如下：

（1）new分配内存空间无需指定分配内存大小，malloc需要；

（2）new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；

（3）new是从自由存储区获得内存，malloc从堆中获取内存；

（4）对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。

什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？
【参考资料】：《游戏引擎架构》P111、前文内存管理部分的参考资料

（1）内存对齐的原因：关键在于CPU存取数据的效率问题。为了提高效率，计算机从内存中取数据是按照一个固定长度的。比如在32位机上，CPU每次都是取32bit数据的，也就是4字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度；
>假设有一个struct结构体如下：
cpp
struct Data {
    char a;
    short b;
    int c;
};
如果不进行内存对齐，a可能位于一个 4 字节内存块的最后一个字节，b位于下一个 4 字节内存块的前两个字节，c位于再下一个 4 字节内存块。当 CPU 读取b的值时，需要从两个内存块中读取数据。假设第一个内存块的内容为0x12345678，第二个内存块的内容为0x9ABCDEF0，b的值实际上是由第一个内存块的低 2 位和第二个内存块的高 14 位组成。
首先使用掩码0x00000003与第一个内存块的数据进行按位与操作，得到0x00000002（即第一个内存块的低 2 位）。
然后使用掩码0xFFFFFC00与第二个内存块的数据进行按位与操作，得到0x9ABCDE00（即第二个内存块的高 14 位）。
最后将第一个结果左移 14 位，再与第二个结果进行按位或操作，得到0x9ABCDE02，这就是b的值。
可以看到，为了获取b的值，需要进行多次掩码和移位操作，这比直接从对齐的内存地址读取数据要复杂得多，效率也低很多。而内存对齐可以确保数据存储在连续的、适合 CPU 读取的内存地址上，避免了这些额外的操作，从而提高了数据读取的效率。

（2）内容：内存对齐指的是C++结构体中的数据成员，其内存地址是否为其对齐字节大小的倍数。

（3）对齐原则：1）结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除；2）结构体内每一个成员的相对于起始地址的偏移量能够被该变量的大小整除；3）结构体总体大小能够被最宽成员大小整除；如果不满足这些条件，编译器就会进行一个填充(padding)。

（4）如何对齐：声明数据结构时，字节对齐的数据依次声明，然后小成员组合在一起，能省去一些浪费的空间，不要把小成员参杂声明在字节对齐的数据之间。

1.4 类型转换（⭐⭐）
C++有哪些类型转换的方法(关键字)，各自有什么作用？
【参考资料】：《C++Primer》P144/730、《Effective C++》条款27

（1）const_cast: 把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；

（2）static_cast: 隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、 int、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象；

（3）dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用dynamic_cast父类一定要有虚函数，否则编译不通过；

（4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）

static_cast和dynamic_cast的异同点？
答：二者都会做类型安全检查，只是static_cast在编译期进行类型检查，dynamic_cast在运行期进行类型检查。后者需要父类具备虚函数，而前者不需要。

dynamic_cast的原理，如何自行实现？
https://blog.csdn.net/zqxf123456789/article/details/106245816/ (这个问题暂时没有找到写得很详细的文章，自己也不是很了解，但是面试中的确出现过一两次，就暂时不写了)

## 1.5 智能指针

- C++中的智能指针有哪些，各自有什么作用?
【参考资料】《C++Primer》13.5.1章节

智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：

（1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；

（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；

（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

- shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？
（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；

（2）具体实现：

1）构造函数：将指针指向该对象，引用计数置为1；

2）拷贝构造函数：将指针指向该对象，引用计数++；

3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。

（3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。shared_ptr是线程安全的吗？ - 云+社区 - 腾讯云 (tencent.com)

- weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw ptr来解决这个问题？
答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。

## 1.6 各种关键字

- const的作用？指针常量和常量指针？const修饰的函数能否重载？
【参考资料】：《C++Primer》2.4节

（1）const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员；

（2）指针常量指的是该指针本身是一个常量，不能被修改，但是指针指向的对象可以被修改，常量指针指的是这个指针指向的对象是一个常量，不能被修改，但是指针本身可以被修改。这涉及到一个顶层const和底层const的概念：顶层const，本身是const，底层const，指向的对象是const；

（3）const修饰的函数可以重载。const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；const类对象只能调用const成员函数，非const对象无论是否是const成员函数都能调用，但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。

- static的作用？static变量什么时候初始化？
【参考资料】《游戏引擎架构》P111、《C++Primer》12.6小节、静态变量的初始化

static即静态的意思，可以对变量和函数进行修饰。分三种情况：

（1）当用于文件作用域的时候（即在.h/.cpp文件中直接修饰变量和函数），static意味着这些变量和函数只在本文件可见，其他文件是看不到也无法使用的，可以避免重定义的问题。

（2）当用于函数作用域时，即作为局部静态变量时，意味着这个变量是全局的，只会进行一次初始化，不会在每次调用时进行重置，但只在这个函数内可见。

（3）当用于类的声明时，即静态数据成员和静态成员函数，static表示这些数据和函数是所有类对象共享的一种属性，而非每个类对象独有。

（4）static变量在类的声明中不占用内存，因此必须在.cpp文件中定义类静态变量以分配内存。文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量在第一次使用时分配内存并初始化。

extern的作用?
答：当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的；当它作为一个对函数或者全局变量的外部声明，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。

explicit的作用？
答：标明类的构造函数是显式的，不能进行隐式转换。

constexpr的作用？
答：这个关键字明确的告诉编译器应该去验证(函数或变量)在编译期是否就应该是一个常数（这样编译器就可以大胆进行优化）。

volatile的作用？
答：跟编译器优化有关，告诉编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的备份。

mutable的作用？
答：可变的意思，使类中被声明为const的函数可以修改类中的非静态成员.

auto和deltype的作用和区别？
答：用于实现类型自动推导，让编译器来操心变量的类型；auto不能用于函数传参和推导数组类型，但deltype可以解决这个问题。

1.7 左值右值，构造函数（⭐）
什么是左值和右值，什么是右值引用，为什么要引入右值引用？
【参考资料】《C++Primer》P121/471、左值和右值_coolwriter的博客-CSDN博客

（1）左值就是具有可寻址的存储单元，并且能由用户改变其值的量，比如常见的变量：一个int，float，class等。左值具有持久的状态，直到离开作用域才销毁；右值表示即将销毁的临时对象，具有短暂的状态，比如字面值常量“hello”，返回非引用类型的表达式int func()等，都会生成右值；

（2）右值引用就是必须绑定到右值的引用，可以通过&&（两个取地址符）来获得右值引用；右值引用只能绑定到即将销毁的对象，因此可以自由地移动其资源；

（3）右值引用是为了支持移动操作而引出的一个概念，它只能绑定到一个将要销毁的对象，使用右值引用的移动操作可以避免无谓的拷贝，提高性能。使用std::move()函数可以将一个左值转换为右值引用。（可以通过两个很长的字符串的直接赋值和移动赋值来测试一下性能的差距)。

为什么要自己定义拷贝构造函数？什么是深拷贝和浅拷贝？
（1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成野指针（悬浮指针）；

（2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

什么是移动构造函数，和拷贝构造函数的区别？
C++11 移动构造函数_项脊轩-CSDN博客_c++ 移动构造

答：移动构造函数需要传递的参数是一个右值引用，移动构造函数不分配新内存，而是接管传递而来对象的内存，并在移动之后把源对象销毁；拷贝构造函数需要传递一个左值引用，可能会造成重新分配内存，性能更低。

1.8 内联函数与宏
内联函数有什么作用？存不存在什么缺点？
（1）作用是使编译器在函数调用点上展开函数，可以避免函数调用的开销；

（2）内联函数的缺点是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销，exe太大，占用CPU资源。此外，内联函数不方便调试，每次修改会重新编译头文件，增加编译时间。

内联函数和宏有什么区别，有了宏为什么还需要内联函数?
（1）define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处直接展开函数，节省了函数调用的开销；

（2）define的话是不会对参数的类型进行检查的，因此会出现类型安全的问题，比如定义一个max命令，但是传递的时候可能会传递一个整数和一个字符串，就会出错，但是内联函数在编译阶段会进行类型检查；

（3）使用宏的时候可能要添加很多括号，比较容易出错。

1.9 杂项
C++11的新特性
（1）auto关键字，可以自动推断出变量的类型；

（2）nullptr来代替NULL，可以避免重载时出现的问题（一个是int，一个是void*）;

（3）智能指针，那三个智能指针，对内存进行管理；

（4）右值引用，基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；

（5）lambda表达式，可以理解为一个匿名的内联函数。

不足之处：没有GC（垃圾回收机制）、没有反射机制等。

指针和引用的区别
（1）指针本质是一个地址，有自己的内存空间，引用只是一个别名；

（2）指针可以指向其他的对象，但是引用不能指向其他的对象，初始化之后就不能改变了；

（3）指针可以初始化为nullptr，而引用必须被初始化为一个已有对象的引用；

（4）指针可以是多级指针，引用只能是一级。

重载、重写和隐藏的区别
（1）重载指的是同一个名字的函数，具有不同的参数列表（参数类型、个数），根据参数列表决定调用哪一个函数；

（2）重写（覆盖）指的是，派生类中的函数重写了基类中的虚函数，重写的基类的中函数必须被声明为virtual，并且返回值，参数列表和基类中的函数一致；

（3）隐藏是指，派生类中的同名函数把基类中的同名函数隐藏了，即基类同名函数被屏蔽掉；此时基类函数不能声明为virtual。

Delete和Delete[]的区别，delete[]如何知道要delete多少次，在类的成员函数中能否Delete This？
【参考资料】：https://blog.csdn.net/cbNotes/article/details/38900799、

https://blog.csdn.net/kuimzzs/article/details/81517451

（1）若是基本类型，delete和delete[]效果是一样的，因为系统会自动记录分配的空间，然后释放；对于自定义数据类型而言（比如类）就不行了，delete仅仅释放数组第一个元素的内存空间，且仅调用了第一个对象的析构函数，但delete[]会调用数组所有元素的析构函数，并释放所有内存空间；

（2）这个问题直接导致我们需要在new []一个对象数组时，需要保存数组的维度，C++的做法是在分配数组空间时多分配了4个字节的大小，专门保存数组的大小，这个数据应该就存在这个分配返回的指针周围，在 delete[]时就可以取出这个保存的数，就知道了需要调用析构函数多少次了；

（3）在类的成员函数可以调用delete this，并且delete this之后还可以调用该对象的其他成员，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。当一个类对象声明时，系统会为其分配内存空间。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。
