---
title: Pre-Game Interview
date: 2025-04-15
tags:
  - UE5
  - C++
  - Game Development
categories: [C++]
description: 基础知识
---

# C++ 基础知识

## 1.1 多态、虚函数

- **什么是多态？C++的多态是如何实现的？**
  - 答：所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态。
    - **编译时多态（静态联编）：**
      - **重载和模板**
        - 函数重载：同一个函数名可以有多个不同的参数列表，编译器根据参数类型和数量来决定调用哪个函数。
        - 模板：函数模板和类模板，允许在编译时生成不同类型的函数或类。
      - **实现原理：** 在编译阶段，编译器根据函数调用语句中提供的参数类型和个数等信息，在符号表中查找与之匹配的函数定义，确定具体要调用的函数版本。
    - **运行时多态（动态联编）：**
      - **继承和虚函数**
        - 继承：允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的复用和扩展。
        - 虚函数：在父类中声明为虚函数的方法，允许在子类中重写，从而实现运行时多态。
      - **实现原理：** 当一个类包含虚函数时，编译器会为该类生成一个虚函数表（vtable），虚函数表中存储了该类所有虚函数的地址。在类对象的内存空间中，会有一个指向虚函数表的指针（虚表指针）。

- **虚函数的实现机制是什么？**
  - 答：虚函数是通过虚函数表来实现的，虚函数表包含了一个类的所有虚函数的地址。

- **虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？**
  - 答：运行时确定，通过查找虚函数表中的函数地址确定。

- **虚函数是存在类中还是类对象中（即是否共享虚表）？**
  - 答：存在类中，不同的类对象共享一张虚函数表（为了节省内存空间）。

- **在(基类的)构造函数和析构函数中调用虚函数会怎么样？**
  - 答：从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）。

- **C语言可以实现虚函数机制吗，如何实现？**
  - 答：需要手动构造父子关系、创建虚函数表、设置虚表指针并指向虚函数表、填充虚函数表。

## 1.2 内存模型、继承问题

- **C++中类对象的内存模型(布局)是怎么样的？**
  - 答：一般遵循以下几点原则：
    1. 如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部；
    2. 除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局；
    3. 如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局；
    4. 如果有钻石继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类。

- **钻石(菱形)继承存在什么问题，如何解决？**
  - 答：会存在二义性的问题，可以采用虚继承的方法解决。

## 1.3 内存管理（内存分配、内存对齐）

- **C++是如何做内存管理的（有哪些内存区域）？**
  - 答：
    1. 堆：使用`malloc`、`free`动态分配和释放空间；
    2. 栈：为函数的局部变量分配内存；
    3. 全局/静态存储区：用于存储全局变量和静态变量；
    4. 常量存储区：专门用来存放常量；
    5. 自由存储区：通过`new`和`delete`分配和释放空间的内存。

- **堆和栈的内存有什么区别？**
  - 答：
    1. 堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放；
    2. 堆能分配的内存较大，栈能分配的内存较小；
    3. 堆的分配效率低，栈的分配效率高。

- **C++和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？**
  - 答：C使用`malloc/free`，C++使用`new/delete`，不能混用。

- **什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？**
  - 答：内存对齐是为了提高CPU存取数据的效率。对齐原则包括：
    1. 结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除；
    2. 结构体内每一个成员的相对于起始地址的偏移量能够被该变量的大小整除；
    3. 结构体总体大小能够被最宽成员大小整除。

## 1.4 类型转换

- **C++有哪些类型转换的方法(关键字)，各自有什么作用？**
  - 答：
    1. `const_cast`: 去掉或添加`const`属性；
    2. `static_cast`: 隐式类型转换；
    3. `dynamic_cast`: 动态类型转换；
    4. `reinterpret_cast`: 重新解释数据的二进制形式。

## 1.5 智能指针

- **C++中的智能指针有哪些，各自有什么作用？**
  - 答：
    1. `shared_ptr`: 多个共享指针可以指向相同的对象；
    2. `unique_ptr`: 保证同一时间段内只有一个智能指针能指向该对象；
    3. `weak_ptr`: 解决`shared_ptr`相互引用时的死锁问题。

## 1.6 各种关键字

- **`const`的作用？指针常量和常量指针？`const`修饰的函数能否重载？**
  - 答：`const`修饰符用来定义常量，具有不可变性。`const`修饰的函数可以重载。

- **`static`的作用？`static`变量什么时候初始化？**
  - 答：`static`可以对变量和函数进行修饰，分为文件作用域、函数作用域和类的声明。

- **`explicit`的作用？**
  - 答：标明类的构造函数是显式的，不能进行隐式转换。

- **`constexpr`的作用？**
  - 答：明确告诉编译器在编译期验证是否为常数。

- **`volatile`的作用？**
  - 答：告诉编译器每次操作该变量时一定要从内存中取出，而不是使用寄存器中的备份。

- **`mutable`的作用？**
  - 答：使类中被声明为`const`的函数可以修改类中的非静态成员。

- **`auto`和`decltype`的作用和区别？**
  - 答：用于实现类型自动推导，`decltype`可以解决`auto`不能用于函数传参和推导数组类型的问题。

## 1.7 左值右值，构造函数

- **什么是左值和右值，什么是右值引用，为什么要引入右值引用？**
  - 答：左值具有持久的状态，右值表示即将销毁的临时对象。右值引用是为了支持移动操作而引入的概念。

- **为什么要自己定义拷贝构造函数？什么是深拷贝和浅拷贝？**
  - 答：拷贝构造函数定义了用同类型的另一个对象初始化本对象时的行为。深拷贝会创建一个新对象，浅拷贝只是复制指针。

- **什么是移动构造函数，和拷贝构造函数的区别？**
  - 答：移动构造函数接管传递而来的对象的内存，拷贝构造函数可能会重新分配内存。

## 1.8 内联函数与宏

- **内联函数有什么作用？存不存在什么缺点？**
  - 答：作用是使编译器在函数调用点上展开函数，缺点是可能造成代码膨胀。

- **内联函数和宏有什么区别，有了宏为什么还需要内联函数？**
  - 答：内联函数在编译阶段展开，宏在预处理阶段替换。内联函数可以进行类型检查，宏不能。

## 1.9 杂项

- **C++11的新特性**
  - 答：包括`auto`关键字、`nullptr`、智能指针、右值引用、`lambda`表达式等。

- **指针和引用的区别**
  - 答：指针有自己的内存空间，可以指向其他对象；引用只是一个别名，初始化后不能改变。

- **重载、重写和隐藏的区别**
  - 答：
    1. 重载：同名函数具有不同的参数列表；
    2. 重写：派生类重写基类的虚函数；
    3. 隐藏：派生类的同名函数屏蔽基类的同名函数。

- **`delete`和`delete[]`的区别**
  - 答：`delete`仅释放第一个元素的内存空间，`delete[]`会调用数组所有元素的析构函数并释放所有内存空间。


