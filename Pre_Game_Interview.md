---
title: Pre-Game Interview
date: 2025-4-15
tags:
  - UE5
  - C++
  - Game Development
categories: [C++]
description: 基础知识
---

# C++ 基础知识

## 1.1 多态、虚函数

- **什么是多态？C++的多态是如何实现的？**

  答：所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态，编译时多态也称为为静态联编，通过重载和模板来实现，运行时多态称为动态联编，通过继承和虚函数来实现。

  - **重载和模板**
    - 函数重载：同一个函数名可以有多个不同的参数列表，编译器根据参数类型和数量来决定调用哪个函数。
    - 实现编译时多态的原理：在编译阶段，编译器根据函数调用语句中提供的参数类型和个数等信息，在符号表中查找与之匹配的函数定义，确定具体要调用的函数版本。由于这种函数调用的绑定是在编译期间完成的，所以称为编译时多态（静态联编）。
    - 模板：函数模板和类模板，允许在编译时生成不同类型的函数或类。
    - 实现编译时多态的原理：在编译阶段，当编译器遇到模板函数的调用时，会根据实际传入的参数类型，对模板进行实例化，生成具体的函数代码。不同的参数类型会导致生成不同的函数实例，从而实现了在编译时根据不同的数据类型调用不同的函数版本，达到编译时多态（静态联编）的效果。

  - **继承和虚函数**
    - 继承：允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的复用和扩展。
    - 虚函数：在父类中声明为虚函数的方法，允许在子类中重写，从而实现运行时多态。
    - 实现运行时多态的原理：当一个类包含虚函数时，编译器会为该类生成一个虚函数表（vtable），虚函数表中存储了该类所有虚函数的地址。在类对象的内存空间中，会有一个指向虚函数表的指针（虚表指针）。当通过基类指针或引用调用虚函数时，程序会根据这个虚表指针找到对应的虚函数表，然后根据虚函数表中存储的函数地址来调用实际的函数。由于派生类重写虚函数时会更新虚函数表中相应的函数地址，所以通过基类指针或引用调用虚函数时，能够根据对象的实际类型（是基类对象还是派生类对象）来调用正确的函数版本，实现了运行时多态（动态联编）。

  - **lua通过metatable实现多态**
    metatable是lua中一个特殊的表，用于实现对象的行为和属性的重载。通过设置metatable，可以定义对象的行为，比如加法、减法等操作符的重载，以及方法的调用等。lua中的多态主要体现在函数和方法的调用上，通过不同的参数类型和数量，可以实现不同的行为。lua中的多态是通过动态类型系统来实现的，不同于C++中的静态类型系统，lua在运行时根据实际传入的参数类型来决定调用哪个函数或方法，从而实现多态性。

**类对象的头部存放着一个虚指针，该虚指针指向了各自类所维护的虚函数表，再通过查找虚函数表中的地址来找到对应的虚函数。**

**在使用基类指针调用虚函数的时候，它能够根据所指的类对象的不同来正确调用虚函数。而这些能够正常工作，得益于虚指针和虚函数表的引入，使得在程序运行期间能够动态调用函数。**

> **基类 Animal 的虚函数表**： https://zhuanlan.zhihu.com/p/98776075
> 当编译器处理 Animal 类时，由于它包含虚函数 speak 和 move，会为 Animal 类生成一个虚函数表。
> 虚函数表中存储了这两个虚函数的地址，即 Animal::speak 和 Animal::move 的函数地址。
>
> **派生类 Dog 的虚函数表**：
> Dog 类继承自 Animal 类，并且重写了 speak 和 move 函数。
> 编译器会为 Dog 类生成自己的虚函数表，该虚函数表首先继承了 Animal 类虚函数表的结构。
> 然后，对于重写的函数，虚函数表中相应的函数地址会被更新为 Dog::speak 和 Dog::move 的函数地址。
>
> **派生类 Cat 的虚函数表**：
> 同理，Cat 类也继承自 Animal 类，并重写了 speak 和 move 函数。
> 编译器为 Cat 类生成虚函数表，继承 Animal 类虚函数表结构，同时将重写函数的地址更新为 Cat::speak 和 Cat::move 的函数地址。

- **虚函数的实现机制是什么？**

  答：虚函数是通过虚函数表来实现的，虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针(虚表指针)，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数。

- **虚函数调用是在编译定还是运行时确定的？如何确定调用哪个函数？**
  答：运找虚函数表中的函数地址确定。更正：此处说法不严谨，应该是只有通过指针或者引用的方式调用虚函数是运行时确定，通过值调用的虚函数是编译期就可以确定的，参考这篇文章，虚函数一定是运行期才绑定么？https://www.zhihu.com/question/491602524/answer/2165605549

- **虚函数更正：此处说法不严谨，应该是只有通过指针或者引用的方式调用虚函数是运行时确定，通过值调用的虚函数是编译期就可以确定的，参考这篇文章，虚函数一定是运行期才绑定么？https://www.zhihu.com/question/491602524/answer/2165605549**
  在类中还是类对象中（即是否共享虚表）？
  答：存在类中，不同的类对象共享一张虚函数表(为了节省内存空间)。

**动态绑定是根据对象的实际类型在运行时确定调用虚函数的具体版本**

- **在(基类的)构造函数和析构函数中调用虚函数会怎么样？**
  【参考资料】：《Effective C++》条款9、https://www.cnblogs.com/sylar5/p/11523992.html
  答：从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，此时子类还没有构造，所以此时的对象还是父类的，不会触发多态。更容易记的是基类构造期间，virtual函数不是virtual函数。

>（1）不要在构造函数中调用虚函数的原因：因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化， 因此调用子类的虚函数是不安全的，故而C++不会进行动态联编。
>（2）不要在析构函数中调用虚函数的原因：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。

当使用基类指针或引用指向派生类对象，并且通过这个基类指针或引用释放对象时，就需要将基类的析构函数声明为 virtual。
 Base* ptr = new Derived();，Base是基类指针，Derived是派生类对象，ptr指向Derived对象，delete ptr时会调用Base的析构函数，如果Base的析构函数不是virtual，则只会调用Base的析构函数，而不会调用Derived的析构函数，导致内存泄漏。

一、构造过程
当创建一个包含继承关系且有成员对象的类的对象时，构造过程遵循以下固定顺序：
基类构造：
无论派生类使用的是默认构造函数还是带参数构造函数，都会先调用基类的构造函数。
若派生类构造函数没有显式指定调用基类的哪个构造函数，就会调用基类的默认构造函数。
若派生类构造函数显式指定了基类构造函数（如在初始化列表中指定），则会调用指定的基类构造函数。
成员对象构造：
基类构造完成后，会按照成员对象在类中声明的顺序依次调用它们的构造函数。成员对象的构造顺序只取决于其在类中声明的先后顺序，与在派生类构造函数初始化列表中的顺序无关。
派生类构造：
基类和成员对象的构造都完成后，最后调用派生类自身的构造函数。
二、析构过程
析构过程与构造过程相反，当对象的生命周期结束（如离开作用域或使用 delete 释放动态分配的对象）时，析构函数按照以下顺序调用：
派生类析构：首先调用派生类的析构函数，对派生类自身的资源进行清理。
成员对象析构：接着按照成员对象在类中声明的相反顺序依次调用它们的析构函数，释放成员对象所占用的资源。
基类析构：最后调用基类的析构函数，清理基类部分的资源。
三、虚析构函数的影响
在使用基类指针或引用指向派生类对象的场景下，基类析构函数是否为虚函数会对析构过程产生重要影响：
非虚析构函数：如果基类析构函数不是虚函数，当通过基类指针或引用释放派生类对象时，只会调用基类的析构函数，派生类的析构函数不会被调用，这可能导致派生类部分的资源无法正确释放，造成内存泄漏等问题。
虚析构函数：如果基类析构函数是虚函数，当通过基类指针或引用释放派生类对象时(基类是虚函数，派生类就算不用virtual标记也默认是虚函数)，会根据指针或引用所指向对象的实际类型来调用相应的析构函数。即先调用派生类的析构函数，再调用基类的析构函数，确保所有资源都能被正确释放。

- **C语言可以实现虚函数机制吗，如何实现？**
  【参考资料】：C语言实现虚函数机制 https://blog.csdn.net/mieleizhi0522/article/details/100674868
  答：需要做的工作：手动构造父子关系、创建虚函数表、设置虚表指针并指向虚函数表、填充虚函数表；当虚函数重写的时候还需要手动修改函数指针等等。

## 1.2 内存模型、继承问题

- **c++中类对象的内存模型(布局)是怎么样的？**
  参考资料：C++内存模型 - MrYun - 博客园 (cnblogs.com)、C++内存布局（上）_qinm的专栏-CSDN博客

  答：一般遵循以下几点原则：

  （1）如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部；

  （2）除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局；

  （3）如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局(虚表指针+字段）；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到第一个虚函数表的后面；

  （4）如果有钻石继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(最上方的父类，包含虚表)，并且各个父类不再拷贝公共基类中的数据成员。

- **钻石(菱形)继承存在什么问题，如何解决？**
  【参考资料】：C++之钻石问题和解决方案（菱形继承问题）_Benson的专栏-CSDN博客https://www.cnblogs.com/yunlambert/p/9876491.html、C++：钻石继承与虚继承 - Tom文星 - 博客园 (cnblogs.com)https://blog.csdn.net/u012658346/article/details/50775742

  答：会存在二义性的问题，因为两个父类会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，也会导致编译错误。可以采用虚继承的方法解决这个问题(父类继承公共基类时用virtual修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。

## 1.3 内存管理（内存分配、内存对齐）

- **C++是如何做内存管理的（有哪些内存区域）?**
  【参考资料】：C++内存管理 - 还没放弃的老张 - 博客园 (cnblogs.com)https://www.cnblogs.com/learning-zjx/p/10645659.html

  （1）堆，使用malloc、free动态分配和释放空间，能分配较大的内存；

  （2）栈，为函数的局部变量分配内存，能分配较小的内存；

  （3）全局/静态存储区，用于存储全局变量和静态变量；

  （4）常量存储区，专门用来存放常量；

  （5）自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。

  补充：堆是C和操作系统的术语，自由存储区是C++的术语，指的是通过new和delete动态分配和释放对象的抽象概念；基本上C++也会用堆区实现自由存储，但程序员可以通过重载操作符，改用其他内存实现自由存储，比如全局变量做的对象池。

- **堆和栈的内存有什么区别？**
  （1）堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放；

  （2）堆能分配的内存较大（4G(32位机器)），栈能分配的内存较小（1M）；

  （3）在堆中分配和释放内存会产生内存碎片，栈不会产生内存碎片；

  （4）堆的分配效率低，栈的分配效率高；

  （5）堆地址从低向上，栈由高向下。

- **C++和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？**
  C使用malloc/free，C++使用new/delete，前者是C语言中的库函数，后者是C++语言的运算符，对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数，只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间，不能混用，具体区别如下：

  （1）new分配内存空间无需指定分配内存大小，malloc需要；

  （2）new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；

  （3）new是从自由存储区获得内存，malloc从堆中获取内存；

  （4）对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。

- **什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？**
  【参考资料】：《游戏引擎架构》P111、前文内存管理部分的参考资料

  （1）内存对齐的原因：关键在于CPU存取数据的效率问题。为了提高效率，计算机从内存中取数据是按照一个固定长度的。比如在32位机上，CPU每次都是取32bit数据的，也就是4字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度；

  >假设有一个struct结构体如下：
  ```cpp
  struct Data {
      char a;
      short b;
      int c;
  };
  ```
  如果不进行内存对齐，a可能位于一个 4 字节内存块的最后一个字节，b位于下一个 4 字节内存块的前两个字节，c位于再下一个 4 字节内存块。当 CPU 读取b的值时，需要从两个内存块中读取数据。假设第一个内存块的内容为0x12345678，第二个内存块的内容为0x9ABCDEF0，b的值实际上是由第一个内存块的低 2 位和第二个内存块的高 14 位组成。
  首先使用掩码0x00000003与第一个内存块的数据进行按位与操作，得到0x00000002（即第一个内存块的低 2 位）。
  然后使用掩码0xFFFFFC00与第二个内存块的数据进行按位与操作，得到0x9ABCDE00（即第二个内存块的高 14 位）。
  最后将第一个结果左移 14 位，再与第二个结果进行按位或操作，得到0x9ABCDE02，这就是b的值。
  可以看到，为了获取b的值，需要进行多次掩码和移位操作，这比直接从对齐的内存地址读取数据要复杂得多，效率也低很多。而内存对齐可以确保数据存储在连续的、适合 CPU 读取的内存地址上，避免了这些额外的操作，从而提高了数据读取的效率。

  （2）内容：内存对齐指的是C++结构体中的数据成员，其内存地址是否为其对齐字节大小的倍数。

  （3）对齐原则：1）结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除；2）结构体内每一个成员的相对于起始地址的偏移量能够被该变量的大小整除；3）结构体总体大小能够被最宽成员大小整除；如果不满足这些条件，编译器就会进行一个填充(padding)。

  （4）如何对齐：声明数据结构时，字节对齐的数据依次声明，然后小成员组合在一起，能省去一些浪费的空间，不要把小成员参杂声明在字节对齐的数据之间。

## 1.4 类型转换

- **C++有哪些类型转换的方法(关键字)，各自有什么作用？**
  【参考资料】：《C++Primer》P144/730、《Effective C++》条款27

  （1）const_cast: 把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；

  （2）static_cast: 隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、 int、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象；

  （3）dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用dynamic_cast父类一定要有虚函数，否则编译不通过；

  （4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）

- **static_cast和dynamic_cast的异同点？**
  答：二者都会做类型安全检查，只是static_cast在编译期进行类型检查，dynamic_cast在运行期进行类型检查。后者需要父类具备虚函数，而前者不需要。

- **dynamic_cast的原理，如何自行实现？**
  https://blog.csdn.net/zqxf123456789/article/details/106245816/ (这个问题暂时没有找到写得很详细的文章，自己也不是很了解，但是面试中的确出现过一两次，就暂时不写了)

## 1.5 智能指针

- **C++中的智能指针有哪些，各自有什么作用?**
  【参考资料】《C++Primer》13.5.1章节

  智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：

  （1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；

  （2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；

  （3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

- **shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？**
  （1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；

  （2）具体实现：

  1）构造函数：将指针指向该对象，引用计数置为1；

  2）拷贝构造函数：将指针指向该对象，引用计数++；

  3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。

  （3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。

- **weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw ptr来解决这个问题？**
  答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。
  使用 std::weak_ptr：将 B 类中的 a_ptr 类型改为`std::weak_ptr<A>`，这样 b 对 a 的引用不会增加 a 的引用计数。

## 1.6 各种关键字

- **const的作用？指针常量和常量指针？const修饰的函数能否重载？**
  【参考资料】：《C++Primer》2.4节

  （1）const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员；(加mutable也行)

  （2）**指针常量**(int \*const p)指的是该**指针本身是一个常量**，不能被修改，但是指针指向的对象可以被修改，常量指针(const int \*p / int const \*p)(主要看\*指在哪里)指的是这个指针指向的对象是一个常量，不能被修改，但是指针本身可以被修改。这涉及到一个顶层const和底层const的概念：顶层const，本身是const，底层const，指向的对象是const；

  （3）const修饰的函数可以重载。const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；const类对象只能调用const成员函数，非const对象无论是否是const成员函数都能调用，但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。

- **static的作用？static变量什么时候初始化？**
  【参考资料】《游戏引擎架构》P111、《C++Primer》12.6小节、静态变量的初始化

  static即静态的意思，可以对变量和函数进行修饰。分三种情况：

  （1）当用于文件作用域的时候（即在.h/.cpp文件中直接修饰变量和函数），static意味着这些变量和函数只在本文件可见，其他文件是看不到也无法使用的，可以避免重定义的问题。

  （2）当用于函数作用域时，即作为局部静态变量时，意味着这个变量是全局的，只会进行一次初始化，不会在每次调用时进行重置，但只在这个函数内可见。

  （3）当用于类的声明时，即静态数据成员和静态成员函数，static表示这些数据和函数是所有类对象共享的一种属性，而非每个类对象独有。

  （4）static变量在类的声明中不占用内存，因此必须在.cpp文件中定义类静态变量以分配内存。文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量在第一次使用时分配内存并初始化。

- **extern的作用?**
  答：当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的；当它作为一个对函数或者全局变量的外部声明，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。

- **explicit的作用？**
  答：标明类的构造函数是显式的，不能进行隐式转换。shared_ptr构造时候用了explicit
  > 隐式类型转换是指在某些情况下，编译器自动将一种数据类型转换为另一种数据类型，而无需程序员显式地指定转换操作。例如，在将一个整数赋值给一个浮点数变量时，编译器会自动进行隐式转换。
  > 显式类型转换是指程序员明确地指定要进行的类型转换操作，例如使用 static_cast、dynamic_cast、const_cast 或 reinterpret_cast 等关键字进行转换。

如果正确地创建独立的 `std::shared_ptr` 来管理同一个对象，引用计数机制会保证对象仅被删除一次。但问题在于，当允许隐式转换时，很容易不小心让多个独立构造的 `std::shared_ptr` 指向同一个原始指针，而这些 `std::shared_ptr` 彼此并不知道对方的存在，它们的引用计数是独立维护的，这就会导致重复删除问题。

让我们看一个具体的例子，假设 `std::shared_ptr` 的构造函数没有使用 `explicit` 关键字，允许隐式转换：

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "MyClass constructor" << std::endl; }
    ~MyClass() { std::cout << "MyClass destructor" << std::endl; }
};

void func1(std::shared_ptr<MyClass> ptr) {
    // 函数逻辑
}

void func2(std::shared_ptr<MyClass> ptr) {
    // 函数逻辑
}

int main() {
    MyClass* rawPtr = new MyClass();
    func1(rawPtr); // 隐式转换，创建一个 std::shared_ptr 管理 rawPtr
    func2(rawPtr); // 再次隐式转换，创建另一个 std::shared_ptr 管理 rawPtr
    return 0;
}
```

详细过程

1. **`main` 函数中**：使用 `new` 操作符创建了一个 `MyClass` 对象，并将其地址赋给原始指针 `rawPtr`。
2. **调用 `func1` 时**：由于允许隐式转换，`rawPtr` 被隐式转换为 `std::shared_ptr<MyClass>`。这个新创建的 `std::shared_ptr` 会将引用计数初始化为 1，因为它认为自己是唯一管理该对象的智能指针。
3. **调用 `func2` 时**：同样进行隐式转换，又创建了一个新的 `std::shared_ptr<MyClass>` 来管理 `rawPtr`。这个新的 `std::shared_ptr` 并不知道之前已经有一个 `std::shared_ptr` 在管理该对象，所以它也将引用计数初始化为 1。
4. **`func1` 和 `func2` 返回时**：各自的 `std::shared_ptr` 超出作用域，引用计数减为 0，它们都会尝试删除所管理的对象。由于它们管理的是同一个原始指针，这就导致对象被重复删除，从而引发未定义行为。

使用 `explicit` 关键字的好处

当 `std::shared_ptr` 的构造函数使用 `explicit` 关键字时，上述代码会在编译时出错，因为不允许隐式转换。开发者必须显式地构造 `std::shared_ptr`，这样可以避免无意中创建多个独立的 `std::shared_ptr` 管理同一个原始指针，从而保证引用计数机制正常工作，避免重复删除问题。例如：

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "MyClass constructor" << std::endl; }
    ~MyClass() { std::cout << "MyClass destructor" << std::endl; }
};

void func1(std::shared_ptr<MyClass> ptr) {
    // 函数逻辑
}

void func2(std::shared_ptr<MyClass> ptr) {
    // 函数逻辑
}

int main() {
    std::shared_ptr<MyClass> sharedPtr = std::make_shared<MyClass>();
    func1(sharedPtr); // 正确传递，引用计数加 1
    func2(sharedPtr); // 正确传递，引用计数加 1
    // 当 sharedPtr 以及 func1 和 func2 中的副本都超出作用域时，引用计数减为 0，对象被删除一次
    return 0;
}
```

在这个例子中，通过显式构造 `std::shared_ptr`，所有的 `std::shared_ptr` 都共享同一个引用计数，确保对象只被删除一次。

- **constexpr的作用？**
  答：这个关键字明确的告诉编译器应该去验证(函数或变量)在编译期是否就应该是一个常数（这样编译器就可以大胆进行优化）。

- **volatile的作用？**
  答：跟编译器优化有关，告诉编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的备份。

- **mutable的作用？**
  答：可变的意思，使类中被声明为const的函数可以修改类中的非静态成员.

  ```cpp
  class A {
      mutable int a;
      void func() const {
          a = 1; // OK
      }
  };
  ```

- **auto和deltype的作用和区别？**
  答：用于实现类型自动推导，让编译器来操心变量的类型；auto不能用于函数传参和推导数组类型，但deltype可以解决这个问题。

## 1.7 左值右值，构造函数

- **什么是左值和右值，什么是右值引用，为什么要引入右值引用？**
  【参考资料】《C++Primer》P121/471、左值和右值_coolwriter的博客-CSDN博客

  **能用&取出地址的都是左值，其他的都是右值**

  （1）左值就是具有可寻址的存储单元，并且能由用户改变其值的量，比如常见的变量：一个int，float，class等。左值具有持久的状态，直到离开作用域才销毁；右值表示即将销毁的临时对象，具有短暂的状态，比如字面值常量“hello”，返回非引用类型的表达式int func()等，都会生成右值；

  （2）右值引用就是必须绑定到右值的引用，可以通过&&（两个取地址符）来获得右值引用；右值引用只能绑定到即将销毁的对象，因此可以自由地移动其资源；

  （3）右值引用是为了支持移动操作而引出的一个概念，它只能绑定到一个将要销毁的对象，使用右值引用的移动操作可以避免无谓的拷贝，提高性能。使用std::move()函数可以将一个左值转换为右值引用。（可以通过两个很长的字符串的直接赋值和移动赋值来测试一下性能的差距)。

  ```cpp
  std::string str1 = "hello world";
  std::string str2 = std::move(str1); // str1变成了右值引用，str2直接接管了str1的内存
  ```

- **为什么要自己定义拷贝构造函数？什么是深拷贝和浅拷贝？**
  （1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成野指针（悬浮指针）；

  （2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

  > 这里呼应了shared_ptr的拷贝构造函数的实现原理：当进行拷贝构造或赋值操作时，不会复制对象本身，而是复制指针，并且将引用计数加 1。多个 std::shared_ptr 可以指向同一个对象，它们共享引用计数。

- **什么是移动构造函数，和拷贝构造函数的区别？**
  C++11 移动构造函数_项脊轩-CSDN博客_c++ 移动构造

  答：移动构造函数需要传递的参数是一个右值引用，移动构造函数不分配新内存，而是接管传递而来对象的内存，并在移动之后把源对象销毁；拷贝构造函数需要传递一个左值引用，可能会造成重新分配内存，性能更低。
  移动就是把原本的移过来了，原先的自然就没有了；拷贝是把原先的复制了一份，原先的还是在的。

## 1.8 内联函数与宏

- **内联函数有什么作用？存不存在什么缺点？**
  （1）作用是使编译器在函数调用点上展开函数，可以避免函数调用的开销；

  （2）内联函数的缺点是可能造成代码膨胀，尤其是递归的函数，会造成大量内存开销，exe太大，占用CPU资源。此外，内联函数不方便调试，每次修改会重新编译头文件，增加编译时间。

```cpp
inline int max(int a, int b) {
    return a > b ? a : b;
}
```

- **内联函数和宏有什么区别，有了宏为什么还需要内联函数?**
  （1）define宏命令是在预处理阶段对命令进行替换，inline是在编译阶段在函数调用点处直接展开函数，节省了函数调用的开销；

  （2）define的话是不会对参数的类型进行检查的，因此会出现类型安全的问题，比如定义一个max命令，但是传递的时候可能会传递一个整数和一个字符串，就会出错，但是内联函数在编译阶段会进行类型检查；

  （3）使用宏的时候可能要添加很多括号，比较容易出错。

- **从 C++ 源文件到可执行文件的整个过程包括预处理、编译、汇编、链接四个阶段，具体如下：**
  预处理阶段：处理以\#开头的预处理指令，如\#include包含头文件，会把头文件的内容插入到源文件中；\#define定义宏，会进行宏替换；还有\#ifdef \#else \#endif等条件编译指令，根据条件决定代码的取舍。生成的结果是一个中间的预编译文件。
  编译阶段：对预编译文件进行处理，先进行词法分析，将字符流转化为单词序列；接着进行语法分析，根据语法规则构建语法树；然后进行语义分析，检查代码的语义正确性；最后进行优化，如常量折叠、死代码消除、循环展开等，以提高代码执行效率，生成汇编文件。(写的一些烂代码会被优化掉)
  汇编阶段：将汇编文件中的汇编语言指令转换成机器码，生成可重定位目标文件（.obj 文件）。汇编器根据汇编指令和机器指令的对照表一一翻译，每一个汇编语句几乎都对应一条机器指令。
  链接阶段：将多个可重定位目标文件和所需要的库连接成可执行文件（.exe 文件）。链接器会解决符号引用问题，将各个目标文件中的符号（如函数名、变量名等）进行解析和重定位，使其在最终的可执行文件中能够正确地相互引用和调用。

## 1.9 杂项

- **C++11的新特性**
  （1）auto关键字，可以自动推断出变量的类型；

  （2）***nullptr来代替NULL，可以避免重载时出现的问题(一个是int，之前NULL就是个0，在函数重载的时候会被当成int从而进入错误的函数，一个是void*)**;

  （3）智能指针，那三个智能指针，对内存进行管理；

  （4）右值引用，基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；

  （5）lambda表达式，可以理解为一个匿名的内联函数。

  不足之处：没有GC（垃圾回收机制）、没有反射机制等。

- **指针和引用的区别**
  （1）指针本质是一个地址，有自己的内存空间，引用只是一个别名；

  （2）指针可以指向其他的对象，但是引用不能指向其他的对象，初始化之后就不能改变了；

  （3）指针可以初始化为nullptr，而引用必须被初始化为一个已有对象的引用；

  （4）指针可以是多级指针，引用只能是一级。

- **重载、重写和隐藏的区别**
  （1）重载指的是同一个名字的函数，具有不同的参数列表（参数类型、个数），根据参数列表决定调用哪一个函数；

  （2）重写（覆盖）指的是，派生类中的函数重写了基类中的虚函数，重写的基类的中函数必须被声明为virtual，并且返回值，参数列表和基类中的函数一致；

  （3）隐藏是指，派生类中的同名函数把基类中的同名函数隐藏了，即基类同名函数被屏蔽掉；此时基类函数不能声明为virtual。

- **Delete和Delete[]的区别，delete[]如何知道要delete多少次，在类的成员函数中能否Delete This？**
  【参考资料】：https://blog.csdn.net/cbNotes/article/details/38900799、

  https://blog.csdn.net/kuimzzs/article/details/81517451

  （1）若是基本类型，delete和delete[]效果是一样的，因为系统会自动记录分配的空间，然后释放；对于自定义数据类型而言（比如类）就不行了，delete仅仅释放数组第一个元素的内存空间，且仅调用了第一个对象的析构函数，但delete[]会调用数组所有元素的析构函数，并释放所有内存空间；

  （2）这个问题直接导致我们需要在new []一个对象数组时，需要保存数组的维度，C++的做法是在分配数组空间时多分配了4个字节的大小，专门保存数组的大小，这个数据应该就存在这个分配返回的指针周围，在 delete[]时就可以取出这个保存的数，就知道了需要调用析构函数多少次了；

  （3）在类的成员函数可以调用delete this，并且delete this之后还可以调用该对象的其他成员，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。当一个类对象声明时，系统会为其分配内存空间。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。

- **A 在 B 前面声明，A 能否调用 B 函数：**
  如果仅按照普通的 C++ 全局函数规则，A 在 B 前面声明，A 通常不能直接调用 B 函数，因为编译器在处理 A 函数时，还不知道 B 函数的存在。但可以通过提前声明 B 函数来解决这个问题。比如在文件开头先声明 B 函数（只写函数原型，不写函数体 ），之后定义 A 函数，A 函数就可以调用 B 函数。另外，如果 A 和 B 是类的成员函数，在类的定义范围内，先声明的成员函数可以调用后声明的成员函数，前提是调用发生在类的成员函数定义体中，因为类的成员函数共享类的作用域。

- **函数返回类型不能为数组类型的原因**
内存管理与生命周期问题：在 C/C++ 中，函数调用通过栈来实现，函数结束时栈上局部变量会被释放。若函数返回数组，数组作为局部变量在函数结束时其内存会被回收，调用者无法正确获取数组内容 。例如，函数内创建的局部数组，在函数返回后，该数组占用的栈内存被释放，返回给调用者的数组就成了无效数据。

解决方法：可以返回指向数组的指针，或者使用 std::array 或 std::vector 等 STL 容器来返回数组。
  
```cpp
int[] func() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr;
}
```

- **函数在无需使用形参的值的时候最好使用常量引用**
  答：函数在无需使用形参的值的时候最好使用常量引用，避免了不必要的拷贝开销。

  ```cpp
  void func(const int &a) {
      // do something
  }
  ```


# STL、数据结构、算法

## 2.1 STL各种容器的底层实现？
（1）vector，底层是一块具有连续内存的数组，vector的核心在于其长度自动可变。vector的数据结构主要由三个迭代器(指针)来完成：指向首元素的start，指向尾元素的finish和指向内存末端的end_of_storage。vector的扩容机制是：当目前可用的空间不足时，分配目前空间的两倍或者目前空间加上所需的新空间大小（取较大值），容量的扩张必须经过“重新配置、元素移动、释放原空间”等过程。

（2）list，底层是一个循环双向链表，链表结点和链表分开独立定义的，结点包含pre、next指针和data数据。

（3）deque，双向队列，由分段连续空间构成，每段连续空间是一个缓冲区，由一个中控器来控制。它必须维护一个map指针（中控器指针），还要维护start和finish两个迭代器，指向第一个缓冲区，和最后一个缓冲区。deque可以在前端或后端进行扩容，这些指针和迭代器用来控制分段缓冲区之间的跳转。

（4）stack和queue，栈和队列。它们都是由由deque作为底层容器实现的，他们是一种容器配接器，修改了deque的接口，具有自己独特的性质（此二者也可以用list作为底层实现）；stack是deque封住了头端的开口，先进后出，queue是deque封住了尾端的开口，先进先出。

（5）priority_queue，优先队列。是由以vector作为底层容器，以heap作为处理规则，heap的本质是一个完全二叉树。

（6）set和map。底层都是由红黑树实现的。红黑树是一种二叉搜索树，但是它多了一个颜色的属性。红黑树的性质如下：1）每个结点非红即黑；2）根节点是黑的；3）如果一个结点是红色的，那么它的子节点就是黑色的；4）任一结点到树尾端（NULL）的路径上含有的黑色结点个数必须相同。通过以上定义的限制，红黑树确保没有一条路径会比其他路径多出两倍以上；因此，红黑树是一种弱平衡二叉树，相对于严格要求平衡的平衡二叉树来说，它的旋转次数少，所以对于插入、删除操作较多的情况下，通常使用红黑树。

补充：平衡二叉树(AVL)和红黑树的区别：AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance（旋转操作），导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

## 2.2 STL各种容器的查找、删除和插入的时间复杂度（性能比较）？
【参考资料】：C++STL各种容器的性能比较、【C++】STL各容器的实现，时间复杂度，适用情况分析_Y先森0.0-CSDN博客

（1）vector，vector支持随机访问(通过下标），时间复杂度是O(1)；如果是无序vector查找的时间复杂度是O(n)，如果是有序vector，采用二分查找则是O(log n)；对于插入操作，在尾部插入最快，中部次之，头部最慢，删除同理。vector占用的内存较大，由于二倍扩容机制可能会导致内存的浪费，内存不足时扩容的拷贝也会造成较大性能开销；

（2）list由于底层是链表，不支持随机访问，只能通过扫描的方式查找，复杂度为O(n)，但是插入和删除的速度快，只需要调整指针的指向。（有一种说法是链表每次插入和删除都需要分配和释放内存，会造成较大的性能开销，所以如果频繁地插入和删除，list性能并不好，但很多地方都说list插入删除性能好，这点我还没有验证，希望有人能指出）；list不会造成内存的浪费，占用内存较小；

（3）deque支持随机访问，但性能比vector要低；支持双端扩容，因此在头部和尾部插入和删除元素很快，为O(1)，但是在中间插入和删除元素很慢；

（4）set和map，底层基于红黑树实现，增删查改的时间复杂度近似O(log n)，红黑树又是基于链表实现，因此占用内存较小；

（5）unordered_set和unordered_map，底层是基于哈希表实现的，是无序的。理论上增删查改的时间复杂度是O(1)（最差时间复杂度O(n))，实际上数据的分布是否均匀会极大影响容器的性能。

## 2.3 STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？
内存碎片，https://www.nowcoder.com/discuss/544284985797169152
外部碎片，分段导致的，之前分配的被回收了，但是在两个块中间，没法应用；内部随便，分页导致的，最小页的内容用不完，但是也不能释放掉；

（1）为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器，直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放。当分配的空间大小小于128B时，将使用第二级空间配置器，采用了内存池技术，通过空闲链表来管理内存。

（2）次级配置器的内存池管理技术：每次配置一大块内存，并维护对应的自由链表(free list)。若下次再有相同大小的内存配置，就直接从自由链表中拔出。如果客户端释还小额区块，就由配置器回收到自由链表中；配置器共要维护16个自由链表，存放在一个数组里，分别管理大小为8-128B不等的内存块。分配空间的时候，首先根据所需空间的大小（调整为8B的倍数）找到对应的自由链表中相应大小的链表，并从链表中拔出第一个可用的区块；回收的时候也是一样的步骤，先找到对应的自由链表，并插到第一个区块的位置。

（3）优势：避免内存碎片(这里应该指的是外部碎片)，不需要频繁从用户态切换到内核态，性能高效；劣势：仍然会造成一定的内存浪费，比如申请120B就必须分配128B（内部碎片）。

## 2.4 STL容器的push_back和emplace_back的区别？
【参考资料】《C++ Primer》P308、C++11使用emplace_back代替push_back_华秋实的专栏-CSDN博客

答：emplace/emplace_back函数使用传递来的参数直接在容器管理的内存空间中构造元素（只调用了构造函数）；push_back会创建一个局部临时对象，并将其压入容器中（可能调用拷贝构造函数或移动构造函数）

## 2.5 STL的排序用到了哪种算法，具体如何执行？
【参考资料】：https://feihu.me/blog/2014/sgi-std-sort/

答：快速排序、插入排序和堆排序；当数据量很大的时候用快排，划分区段比较小的时候用插入排序，当划分有导致最坏情况的倾向的时候使用堆排序。

## 2.6 各种排序算法的原理和时间复杂度？
【参考资料】：八大常用排序算法详细分析

（1）快排：一轮划分，选择一个基准值，小于该基准值的元素放到左边，大于的放在右边，此时该基准值在整个序列中的位置就确定了，接着递归地对左边子序列和右边子序列进行划分。时间复杂度o(nlogn)，最坏的时间复杂度是o(n2)；

（2）堆排序：利用完全二叉树性质构造的一个一维数组，用数组下标代表结点，则一个结点的左孩子下标为2i+1,右孩子为2i+2，一个结点的父节点为(i-1)/2。堆排序的思想就是，构造一个最大堆或者最小堆，以最大堆为例，那么最大的值就是根节点，把这个最大值和最后一个结点交换，然后在从前n-1个结点中构造一个最大堆，再重复上述的操作，即每次将现有序列的最大值放在现有数组的最后一位，最后就会形成一个有序数组；求升序用最大堆，降序用最小堆。时间复杂度O(nlogn)；

（3）冒泡排序：从前往后两两比较，逆序则交换，不断重复直到有序；时间复杂度O(n2），最好情况O(n)；

（4）插入排序，类似打牌，从第二个元素开始，把每个元素插入前面有序的序列中；时间复杂度O(n2），最好情况O(n)；

（5）选择排序，每次选择待排序列中的最小值和未排序列中的首元素交换；时间复杂度O(n2）；

（6）归并排序，将整个序列划分成最小的>=2的等长序列，排序后再合并，再排序再合并，最后合成一个完整序列。时间复杂度O(nlogn)。

（7）希尔排序，是插入排序的改进版，取一个步长划分为多个子序列进行排序，再合并(如135一个序列，246一个序列），时间复杂度O(n1.3)，最好O(n)，最坏O(n2)；

（8）桶排序，将数组分到有限数量的桶里。每个桶再个别排序，最后依次把各个桶中的记录列出来记得到有序序列。桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)，M为桶的数量。最好的情况下为O(N)。

## 2.7 如何在一个序列中求前k个最大或者最小的数？
（1）基于快排，每轮划分选择一个基准值，把比它小的数放在左边，大的放在右边，函数返回基准值的位置，如果该位置恰好是K，就说明了这是第K小的数，所以从0-基准值位置的数是序列中的前K小数。若返回基准值的位置小于或者大于K，再进行相应调整：如果返回的基准值大于k，在基准值左边序列查找，如果小于，在基准值右边进行查找。递归地进行快排，直到返回的结果=K；时间复杂度为O(n)。

（2）基于堆排序，求前K个最小的数用最大顶堆，求前K个最大的数用最小顶堆。以最大顶堆为例，要维护一个大小为K的顶堆，就是先将K个数插入堆中，随后，对每一个数，与堆顶的最大元素比较，若该数比堆顶元素小，则替换掉堆顶元素，然后调整堆，若大于堆顶元素，则不管，那么将所有元素比较和插入后，该堆维护的就是最小的K个数。求前k小的数用最大顶堆的目的(原理）：这是一种局部淘汰的思想，尽量的把小的数都放在堆中，最后使得即使堆中最大的数，也比外界的所有数都小，就达到了目的。

- **如何尽可能快地在一个序列中移除指定条件的元素，并不改变其他元素的相对顺序(Remove_If算法的原理），比如一个序列{1，3，2，5，2，2，6，7}移除序列中所有的2？**
  先找到第一个符合条件的元素的位置，然后从这个位置开始，往后扫描不符合条件的元素，逐个的安插到这个位置以及之后的位置，无论是什么元素都直接覆盖（可以用一个指针指向这个要安插和覆盖的位置，往后步进）。该算法时间复杂度为O(n)。

## 2.8 什么是哈希表？哈希表的长度为什么要是质数？如何处理冲突？哈希表怎么删除一个元素？
【参考资料】图文并茂详解数据结构之哈希表 - 知乎 (zhihu.com)

（1）哈希表是一种根据关键码值直接访问数据的数据结构，它通过把关键码值映射到表中的一个位置来访问元素，以加快查找的速度。这个映射函数叫做哈希函数；

（2）哈希表的长度使用质数，可以降低发生冲突的概率，使哈希后的数据更加均匀，如果使用合数，可能会导致很多数据集中分布到一个点上，造成冲突；

（3）解决冲突的办法有开放定址法和拉链法，开放定址法包括线性测探、平方测探法；

（4）线性测探法并不会真正的删除一个元素，而是做一个标记，否则可能会导致正常的查找出错（利用线性探测法解决hash冲突 - 寻觅beyond - 博客园 (cnblogs.com)）

## 2.9 如何用栈实现一个队列？
经典问题，用栈实现队列和用队列实现栈 - wzyy - 博客园 (cnblogs.com)

## 2.10 如何判断链表是否有环？
最快的方法就是用快慢指针法，【算法】如何判断链表有环_Mlib-CSDN博客_判断链表是否有环

## 2.11 capacity和size的区别？
（1）capacity是指容器分配的内存大小，size是指容器中实际存储的元素个数；

# 工程问题

## 3.1编译链接原理，从C++源文件到可执行文件的过程？（⭐⭐）
【参考资料】：https://www.cnblogs.com/dongdongweiwu/p/4743709.html

答：包括四个阶段：预处理阶段、编译阶段、汇编阶段、连接阶段。

（1）预处理阶段处理头文件包含关系，对预编译命令进行替换，生成预编译文件；

（2）编译阶段将预编译文件编译，生成汇编文件（编译的过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码)；

（3）汇编阶段将汇编文件转换成机器码，生成可重定位目标文件（.obj文件）（汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可）；

（4）链接阶段，将多个目标文件和所需要的库连接成可执行文件（.exe文件）。

## 3.2 动态库静态库，二者的含义、区别，以及如何选择？（⭐）

区分在于链接阶段，如何处库，链接成可执行程序的方式不同：

- 静态库：.a .lib文件，在编译时将库文件的代码链接到可执行文件中，生成的可执行文件体积较大，运行时不需要依赖库文件；
- 动态库：.so dll文件，在运行时将库文件的代码链接到可执行文件中，生成的可执行文件体积较小，运行时需要依赖库文件；动态库在内存中只存在一份拷贝，避免了静态库的重复拷贝，节省了内存空间；动态库可以在运行时加载和卸载，方便更新和维护；动态库可以被多个进程共享，节省了磁盘空间。

【参考资料】：C++静态库与动态库 - 吴秦 - 博客园 (cnblogs.com)、计算机那些事(5)——链接、静态链接、动态链接 | 楚权的世界 (chuquan.me)、动态链接库与静态链接库有什么区别？ - 知乎 (zhihu.com)（这部分自己还没有梳理清楚，先放几个参考链接，回头再补上）

## 3.3 vector如何手动释放内存
【参考资料】https://www.cnblogs.com/summerRQ/articles/2407974.html

比如有一个vector<int>nums， 比较hack的一种方式是nums = {}，这样既可以清空元素还会释放内存（从一个大佬身上学来的）；规范的做法是，vector<int>().swap(nums)或者nums.swap(vector<int> ())。
就是和一个空的vector交换，交换后原来的vector就会被销毁，内存也会被释放。

## 3.4 如何拷贝一段数据
（1）C++语法：std::copy(src.begin(), src.end(), dest.begin())；

std::copy_n(src.begin(), int n, dest.begin())；

（2）C风格语法：memcpy(void* dest, const void* src, size_t num)

## 3.5 对象池思想
【参考资料】：对象池--C++对象池的实现_码农之初心-CSDN博客

对于那些需要频繁创建和销毁的对象，对象池的思想是，首先从对象池中寻找有没有可用的对象，如果没有，就创建对象来使用，然后当一个对象不使用的时候，不是把它删除，而是将它设置为不激活的状态并放入对象池中，等待需要使用的时候再去对象池中寻找，并把它激活。

## 3.6 设计模式
（1）单例模式：（⭐⭐）

【参考资料】：C++ 单例模式 - 知乎 (zhihu.com)

单例模式保证保证全局只有唯一一个自行创建的实例对象，并由单例类提供获取这个唯一实例的接口。主要有两种实现方法：

1）懒汉式，用到的时候才会加载，线程不安全，需要加锁；用get instance去获取，在get instance里面定义static Instance并且return

2）饿汉式，在main函数开始的时候即创建对象，线程安全；

C++11标准之后的最佳的选择是Meyers' Singleton（属于懒汉式），它利用了局部静态变量在第一次使用时才初始化的特性，并且由于C++11标准解决了局部静态变量的线程安全问题，使得它成为当前最简洁也最高效的实现方式。

（2）工厂模式：

【参考资料】：C++ 深入浅出工厂模式（初识篇） - 知乎 (zhihu.com)

该模式用来封装和管理类的创建，终极目的是为了解耦，实现创建者和调用者的分离。

工厂模式分为三种：

1）简单工厂，一个工厂生产多种产品，要指定产品的名字进行生产；

2）普通工厂，将产品生产分配给多个工厂，但是每个工厂只生产一种产品；

3）抽象工厂，将产品生产分配给多个工厂，每个工厂可以生产多种产品；

(3) MVC模式

model-view-controller模式，分为三层：
model层：数据模型层，负责数据的存储和处理；
view层：视图层，负责数据的展示；
controller层：控制层，负责业务逻辑的处理；
整体逻辑为：view层接收用户的输入，调用controller层进行处理，controller层调用model层进行数据的存储和处理，最后将结果返回给view层进行展示。

# 四、操作系统、计算机组成、计算机网络

## 4.1 操作系统
【参考资料】：操作系统最强面经面试题总结 | 春招秋招必备 | Offer收割_LonelyPlanet_的博客-CSDN博客_操作系统面经

- **进程和线程的区别？（⭐⭐）**
  进程是系统资源分配的基本单位（可以看成是资源的容器），线程是调度的基本单位。
  （1）进程是运行时的程序，是系统进行资源分配和调度的基本单位，它实现了系统的并发；

  （2）线程是进程的子单位，也称为轻量级进程，它是CPU进行分配和调度的基本单位，也是独立运行的基本单位，它实现了进程内部的并发；

  （3）一个程序至少拥有一个进程，一个进程至少拥有一个线程，线程依赖于进程而存在；

  （4）进程拥有独立的内存空间，而线程是共享进程的内存空间的，自己不占用资源；

  （5）线程的优势：线程之间的信息共享和通讯比较方便，不需要资源的切换等.

- **什么是死锁，死锁的条件以及如何防止？什么是银行家算法？（⭐⭐）**
  （1）死锁就是多个进程并发执行，在各自占有一定资源的情况下，希望获得其他进程占有的资源以推进执行，但是其他资源同样也期待获得另外进程的资源，大家都不愿意释放自己的资源，从而导致了相互阻塞、循环等待，进程无法推进的情况。

  （2）死锁条件：1）互斥条件（一个资源每次只能被一个进程使用）；2）请求并保持条件（因请求资源而阻塞时，对已获得的资源保持不放）；3）不剥夺条件（在未使用完之前，不能剥夺，只能自己释放）；4）循环等待（若干进程之间形成一种头尾相接的循环等待资源关系）。

  （3）死锁防止：1）死锁预防，打破四个死锁条件；2）死锁避免，使用算法来进行资源分配，防止系统进入不安全状态，如银行家算法；3）死锁检测和解除，抢占资源或者终止进程；

  （4）银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。安全的状态指的是一个进程序列{P1,P2,...Pn}，对于每一个进程Pi，它以后尚需要的资源不大于当前资源剩余量和其余进程所占有的资源量之和。

- **操作系统如何管理内存，什么是虚拟内存？**
  通过一种分页管理机制来进行内存管理。分页管理机制将程序的逻辑地址划分为固定大小的页，而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。虚拟内存是基于分页存储管理机制的，它允许程序不必将所有的页都放入内存中，而只是将一部分页映射到内存中，另一部分页放在外存上(如磁盘、软盘、USB），当引用到不在内存中的页时，系统产生缺页中断，并从外存中调入该部分页进来，从而产生一种逻辑上内存得到扩充的感觉，实际上内存并没有增大。

- **什么是内存碎片，内存碎片是在虚拟内存还是物理内存？**
  【参考资料】：内存碎片_百度百科 (baidu.com)

  采用分区式存储管理的系统，在储存分配过程中产生的、不能供用户作业使用的主存里的小分区称成“内存碎片”。内存碎片分为内部碎片和外部碎片。内存碎片只存在于虚拟内存上。

## 4.2 计算机组成
【参考资料】：《计算机组成原理》课本(唐朔飞版）、Cache的基本原理 - 知乎 (zhihu.com)

- **什么是缓存(Cache)？为什么需要缓存？如何提高缓存的命中率？缓存是不是最快的？（⭐⭐）**
  （1）Cache即CPU的高速缓冲存储器，是一种是用于减少处理器访问内存所需平均时间的部件；

  （2）由于CPU的计算速度远远大于从CPU向内存取数据的速度，如果每次都让CPU去内存取数据，会导致CPU计算能力的浪费，所以人们设计了缓存，CPU通过读写缓存来获取操作数，结果也通过缓存写入内存；

  （3）注意程序的局部性原理，在遍历数组时按照内存顺序访问；充分利用CPU分支预测功能，将预测的指令放到缓存中执行；此外缓存的容量和块长是影响缓存效率的重要因素。如何提升CPU的缓存命中率？ - 知乎 (zhihu.com)

  （4）缓存不是最快的，寄存器更快。

- **什么是缓存一致性，如何保证缓存一致性？**
  缓存一致性问题
  在多核处理器系统中，每个核心都有自己的高速缓存（Cache）。当不同核心同时对同一内存地址的数据进行读写操作时，就可能出现缓存数据不一致的情况。例如，核心 A 修改了其缓存中的某一数据，而核心 B 并不知道该数据已被修改，仍然使用自己缓存中的旧数据，这就导致了数据不一致，进而可能引发程序运行错误。
  （1）在多核CPU中，每个核有自己的缓存，在两个核进行独自修改缓存中的数据的时候，就可能会造成数据不一致的问题，就是缓存的一致性问题；

  （2）一个是在总线中加锁，一个是采用缓存一致性协议。

- **一个缓存块的大小是多少，读取内存中的字段是读多少数据取多少内存吗？**
  如果缓存没有命中(即读取一个数据没有在缓存中），不仅需要把该字(数据)从主存中取出，还需要从主存中将它所在的整个字块一次调入缓存中。缓存线(块)的长度是64B。

## 4.3 计算机网络
- **TCP和UDP的区别？**
  （1）TCP是传输控制协议，UDP是用户数据报协议；

  （2）TCP是面向连接的，可靠的数据传输协议，它要通过三次握手来建立连接，UDP是无连接的，不可靠的数据传输协议，采取尽力而为的策略，不保证接收方一定能收到正确的数据；

  （3）TCP面向的是字节流，UDP面向的是数据报；

  （4）TCP只支持点对点，UDP支持一对一，一对多和多对多；

  （5）TCP有拥塞控制机制，UDP没有。


# LUA和其他问题

## 5.1 csv和xlsx的区别？

1）csv是文本文件，可以用记事本打开；xls/xlsx是二进制文件，只有用EXCEL才能打开。
2）csv文件只能保存活动工作表中单元格所显示的文本和数值，数据中每一列以逗号分隔，每一行都以回车换行符结束。如果单元格中包含逗号，则该单元格中的内容以双引号引起。xls/xlsx文件各个单元格之间的分隔符为Tab。
3）csv文件可以用记事本打开，进而转为txt格式的文件；xls/xlsx不能直接转为txt格式。若想转换，则需要另存为csv格式，然后再将csv以txt方式打开，点击另存为txt文件。

## 5.2 pair和ipairs的区别

- `pairs`：遍历表中的所有键值对，包括非整数键（如字符串）。顺序不固定，适用于字典类型的表。
- `ipairs`：仅遍历整数键（1, 2, 3...）的键值对，顺序固定，适用于数组类型的表。遍历到第一个 `nil` 时停止，不会继续遍历后面的元素。

```lua
-- 示例代码
local t = {a = 1, b = 2, c = 3}
print("使用 pairs 遍历:")
for k, v in pairs(t) do
    print(k, v)  -- 输出所有键值对
end

-- 定义一个数组类型的表
local array = {10, 20, 30, nil, 50}
print("使用 ipairs 遍历:")
for k, v in ipairs(array) do
    print(k, v)  -- 仅输出整数键的键值对，遇到 nil 停止
end
```

## 5.3 :和.的区别

```lua
-- 用 : 定义的方法会自动接收一个隐式的 self 参数，指向调用该方法的表（对象）本身。
-- 定义一个表（类似对象）
local obj = {
    value = 10
}

-- 用冒号定义方法（自动添加 self）
function obj:printValue()
    print(self.value) -- 通过 self 访问对象的属性
end

-- 等价于
function obj.printValue(self)
    print(self.value)
end
```


# 项目相关问题

## 6.1 如何防止Actor被自动回收

1. **使用 `UPROPERTY` 标记引用**：将指向 `Actor` 的变量标记为 `UPROPERTY`，通过包含该变量的实例去引用目标 `Actor`，建立强引用关系，使垃圾回收器因该引用存在而不回收目标 `Actor`。
2. **调用 `AddToRoot` 方法**：在创建 `Actor` 对象后调用 `AddToRoot` 函数，将其添加到垃圾回收的根集，阻止被回收。但需注意，在退出游戏或不再需要该 `Actor` 时，要调用 `RemoveFromRoot` 函数，避免内存泄漏。
3. **`FStreamableManager` 加载资源设置**：使用 `FStreamableManager` 加载资源时，将 `bManageActiveHandle` 设置为 `true`，在资源加载相关逻辑中起到防止对应 `Actor` 被回收的作用。
4. **利用 `FGCObjectScopeGuard`**：通过 `FGCObjectScopeGuard` 可在指定的代码区域内保持对象，确保在该区域内 `Actor` 不会被垃圾回收机制处理。

## 6.2 如何优化Tick

1.Tick。这个本身它是必不可少的一个东西，我们能做其实就是减少Tick的频率并且合理设置各个Actor和各个组件的Tick interval，Interval就是每一个Tick的间隔。举个例子我们默认每一个角色其实都是按照一定的固定的Tick在跑，我们面对的角色比如说主角还有一些其他的怪，这些东西有一些可能离我们非常远的，这些离我们比较远的这一些怪物或者人物，我们其实就是可以调节它的Tick的频率，让它以一个比较低的Tick频率去运行从而减少一部分的CPU开销。对不敏感的逻辑可以进行这些分帧的计算，举个例子比如说我们游戏里面UI上有一些红点提示，这些东西它对于这个整个的要求 不要求那么实时，但它的一个计算量很大，本来我们如果把它放在一帧里面去做，那可能这一帧的开销就会比较大，如果我们把它分散到10帧里面去做，主观感受上不会有太大的差异，但是CPU会比较省。

## 6.3 为什么用四元数

欧拉角有万向锁的问题。万向锁就是任意一个轴旋转到和另一个轴重叠，就会失去一个自由度。四元数可以避免这个问题，因为它不依赖于欧拉角的旋转顺序。

旋转矩阵也是为了表示欧拉角的旋转的，而且也没有四元数节省空间。四元数只需要4个数来表示一个旋转，而旋转矩阵需要9个数。四元数的乘法比矩阵乘法更快。四元数的插值比矩阵插值更平滑。四元数可以避免万向锁的问题。

## 6.4 点积和叉积的区别

- 点积：点积是两个向量的数量积，结果是一个标量，表示两个向量之间的夹角余弦值和它们的模长的乘积。点积可以用来判断两个向量之间的夹角关系，比如是否垂直、平行等。
- 叉积：叉积是两个向量的向量积，结果是一个向量，表示两个向量所张成的平行四边形的面积和方向。叉积可以用来判断两个向量之间的垂直关系，以及计算法向量等。
- 计算方式：点积是通过对应元素相乘后求和得到的，而叉积是通过行列式的方式计算的。

```cpp
// 示例代码
FVector A(1, 2, 3);
FVector B(4, 5, 6);

float dotProduct = FVector::DotProduct(A, B);
FVector crossProduct = FVector::CrossProduct(A, B); // 叉积结果是一个向量
```

## 6.5 调试器的原理

系统会提供特定的调用接口。
vs里选择附加到进程的时候，会调用操作系统的调试接口与目标进程建立一个会话。在这个会话期间，调试器能够对目标进程进行控制、暂停和继续执行等操作。
当在调试器中设置断点时，调试器会把断点信息发送给目标进程，目标进程在接收到这些信息后，会在相应的代码位置插入断点指令。

1. 建立调试会话
在 Visual Studio 中选择 “附加到进程” 时，调试器会调用操作系统提供的特定调试接口来与目标进程建立一个调试会话。以 Windows 系统为例，通常会使用 DebugActiveProcess 函数。
DebugActiveProcess 函数：此函数的作用是将调试器附加到一个已经在运行的进程上。一旦调用成功，调试器就成为了目标进程的调试器，能够对目标进程的执行进行监控和控制。调试器和目标进程之间会建立起一个通信通道，用于传递调试相关的信息和指令。
2. 调试器设置断点
当在调试器中设置断点时，背后涉及一系列的操作。
断点信息的封装：调试器会把断点的相关信息进行封装，这些信息包括断点所在的代码位置（例如源代码的行号、对应的内存地址）等。
信息传递：调试器通过之前建立的调试会话，把封装好的断点信息发送给目标进程。这个过程是通过操作系统的调试接口来实现的，调试器和目标进程之间的通信受到操作系统的管理和保护。
3. 目标进程插入断点指令
目标进程在接收到调试器发送的断点信息后，会进行以下操作。
指令插入：在对应的代码位置插入一条特殊的指令，在 x86 架构下通常是 INT 3 指令。INT 3 指令是一个单字节的中断指令，它的作用是触发一个软件中断。当程序执行到这条指令时，会立即停止当前的执行流程，并将控制权交还给操作系统。
内存修改：为了插入断点指令，目标进程需要对自身的内存进行修改。这一操作是在操作系统的允许下进行的，因为调试器已经通过调试接口获得了对目标进程的一定控制权。
4. 目标进程停止执行
当目标进程执行到插入了 INT 3 指令的位置时，会触发软件中断。
中断处理：操作系统会捕获这个中断，并根据调试会话的信息，将控制权转交给调试器。调试器接收到控制权后，会暂停目标进程的执行，此时目标进程就停止在断点处。
调试信息显示：调试器会在界面上更新相关的调试信息，例如显示当前执行的代码行、变量的值等，方便开发者进行调试操作。
5. 在编辑器里修改代码
当目标进程停止在断点处时，开发者可以在编辑器中对代码进行修改。
代码修改：开发者可以对源代码进行修改，例如修改变量的初始值、调整函数的逻辑等。
重新编译和更新：修改完成后，开发者可以选择重新编译修改后的代码。如果是增量编译，编译器会只编译修改过的部分。编译完成后，调试器可以将新的代码更新到目标进程中，然后继续执行程序，观察修改后的效果。